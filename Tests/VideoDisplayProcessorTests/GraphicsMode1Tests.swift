//
//  GraphicsMode1Tests.swift
//  
//
//  Created by Nate Rivard on 07/06/2023.
//

import XCTest
@testable import VideoDisplayProcessor

final class GraphicsMode1Tests: XCTestCase {
    var vdp: VideoDisplayProcessorRef!

    // to be repeated 4 times to fill a full row with different colors
    static let patternData: [UInt8] = [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // all background
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // all foreground
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, // alternating vertical v1
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, // alternating vertical v2
        0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, // alternating horizontal v1
        0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, // alternating horizontal v2
        0x38, 0x44, 0x5C, 0x54, 0x5C, 0x40, 0x38, 0x00, // `@`
        0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00  // `T`
    ]

    static let nameData: [UInt8] = Array(0..<32)

    // there are 32 tiles to make a row, colors apply to groups of 8 patterns, so 4 colors are needed
    static let colorData: [UInt8] = [
        UInt8(kVDPColorWhite.rawValue) << 4 | UInt8(kVDPColorBlack.rawValue),
        UInt8(kVDPColorLightGreen.rawValue) << 4 | UInt8(kVDPColorDarkGreen.rawValue),
        UInt8(kVDPColorDarkRed.rawValue) << 4 | UInt8(kVDPColorGray.rawValue),
        UInt8(kVDPColorDarkYellow.rawValue) << 4 | UInt8(kVDPColorDarkYellow.rawValue)
    ]

    static let line0: [UInt8] = [
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,     // all black
        0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,     // all white
        0x0F, 0x01, 0x0F, 0x01, 0x0F, 0x01, 0x0F, 0x01,     // alternating white then black
        0x01, 0x0F, 0x01, 0x0F, 0x01, 0x0F, 0x01, 0x0F,     // alternating white then black
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,     // all black from horizontal striping
        0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,     // all white from horizontal striping
        0x01, 0x01, 0x0F, 0x0F, 0x0F, 0x01, 0x01, 0x01,     // top line of `0`
        0x01, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x01, 0x01,     // top line of `T`

        0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,     // all dk green
        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,     // all lt green
        0x03, 0x0C, 0x03, 0x0C, 0x03, 0x0C, 0x03, 0x0C,     // alternating lt then dk green
        0x0C, 0x03, 0x0C, 0x03, 0x0C, 0x03, 0x0C, 0x03,     // alternating dk then lt green
        0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,     // all dk green from horizontal striping
        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,     // all lt green from horizontal striping
        0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C,     // top line of `0`
        0x0C, 0x03, 0x03, 0x03, 0x03, 0x03, 0x0C, 0x0C,     // top line of `T`

        0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,     // all grat
        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,     // all red
        0x06, 0x0E, 0x06, 0x0E, 0x06, 0x0E, 0x06, 0x0E,     // alternating red then gray
        0x0E, 0x06, 0x0E, 0x06, 0x0E, 0x06, 0x0E, 0x06,     // alternating gray then red
        0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,     // all gray from horizontal striping
        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,     // all red from horizontal striping
        0x0E, 0x0E, 0x06, 0x06, 0x06, 0x0E, 0x0E, 0x0E,     // top line of `0`
        0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x0E, 0x0E,     // top line of `T`

        0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,     // fg and bg are dark yellow so everything is dark yellow!
        0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
        0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
        0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
        0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
        0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
        0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
        0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A
    ]

    override func setUp() {
        vdp = VDPCreate()

        // put VDP in graphics mode 1
        VDPSetRegister(vdp, 0, 0);
        VDPSetRegister(vdp, 1, 0);

        // setup table addresses
        VDPSetRegister(vdp, 2, 0x05); // 0x1400
        VDPSetRegister(vdp, 3, 0x80); // 0x2000
        VDPSetRegister(vdp, 4, 0x01); // 0x0800
        VDPSetRegister(vdp, 5, 0x20); // 0x1000
        VDPSetRegister(vdp, 6, 0x00); // 0x0000 :)

        // setup vram: patterns, colors, nametable
        VDPSetVramAddress(vdp, 0x1400)  // already primed for writing
        for name in GraphicsMode1Tests.nameData {
            VDPWriteToDataPort(vdp, name)
        }

        VDPSetVramAddress(vdp, 0x2000)
        for color in GraphicsMode1Tests.colorData {
            VDPWriteToDataPort(vdp, color)
        }

        VDPSetVramAddress(vdp, 0x0800)
        for _ in 0..<4 {
            for pattern in GraphicsMode1Tests.patternData {
                VDPWriteToDataPort(vdp, pattern)
            }
        }
    }

    override func tearDown() {
        VDPDestroy(vdp)
    }

    func testTiles() {
        // given is taken care of in setup
        // when
        let scanline = UnsafeMutableBufferPointer<UInt8>.allocate(capacity: Int(kVDPSizeX))

        // then: line 0
        VDPGetScanline(vdp, 0, scanline.baseAddress)
        XCTAssert(Array(scanline) == GraphicsMode1Tests.line0)
    }
}
